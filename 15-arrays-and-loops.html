<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrays and Loops</title>
</head>
<body>
    <script>

        /*
        //Arrays são uma lista de valores basicamente, podendo armazenar qualquer valor disponível em JavaScrypt, sendo ele number, string, object, boolean, etc.

        const myArray = [10, 20, 30];

        console.log(myArray);
        console.log(myArray[0]);
        myArray[0] = 99;
        console.log(myArray[0]);

        //Podemos criar um array em múltiplas linhas sem problemas, já que o que identifica seu inicio e seu final são as square brackets '[]'

        [1,
        'hello',
        true,
        {name: 'socks'},
        [1, 2]
        ]

        console.log(typeof [1, 2]);
        console.log(Array.isArray([1, 2]))

        console.log(myArray.length)

        //Podemos adicionar valores no array, usando o método '.push', podemos incluir um valor sendo o último da lista

        myArray.push(100)
        console.log(myArray)

        //Podemos remover valores do array, uma forma de faze-lo é com o método '.splice', que leva dois valores, o valor inserido primeiro é o index de início do corte e o segundo sendo o valor do index final, porém o último valor não é incluso

        myArray.splice(0, 2)
        console.log(myArray)
        

        let i = 1;
        while (i <= 5) {
            console.log(i);
            i++;
        }

        for (let i = 1; i <= 5; i++) {
            console.log(i)
        }

        let randomNum = 0;

        while(randomNum < 0.50) {
            randomNum = Math.random().toFixed(2);
            console.log(randomNum)
        }

        //Looping through an array, podemos usar o exemplo abaixo para acessar cada um dos valores armazenados em um dado array. Criando a variavel index como condição do loop e recebendo o valor '0', inicia a contagem a partir do primeiro valor armazenado, a condição é que o index deve ser 1 número menor que o número de valores total do array, incrementando por um a cada loop podemos verificar se chegou ao final, caso não, o loop é acionado novamente passando pelo segundo array e verificando novamente, incrementnado index em 1 novamente, e assim sucessivamente

    
    const myTodos = [
    'make dinner',
    'wash dishes',
    'watch youtube',
    ];
    for(let index = 0; index <= myTodos.length -1; index++) {
        const value = myTodos[index]
        console.log(value);
    }
    function addTodoKeydown(event) {
        if(event.key === 'Enter') {
            addTodo();
        } }

        // SHORTCUTS

        for(let i = 0; index < myTodos.length; i++) {
        const value = myTodos[i]
        console.log(value);
    }
    


    //Somando os valores numéricos de um array, accumulator pattern

   const nums = [1, 1, 3];
   let total = 0;

   for(let i = 0; i < nums.length; i++) {
    const num = nums[i];
    // total = total + num;
    total += num;
   }
   console.log(total)

   const numsDoubled = [];
   for(let i = 0; i< nums.length; i++) {
    const num = nums[i];
    numsDoubled.push(num * 2);

    console.log(numsDoubled)
   }



// Um exemplo sobre o comportamento dos objetos, como mencionado anteriormente, os objetos e arrays que usamos na linguagem JavaScript, são referências na memória e não variáveis contendo seus valores como variáveis comuns funcionam, por isso não podemos comparálos diretamente, mesmo igualando o array2 ao array1, ambos possuem a mesma referência na memória, não o mesmo array dentro de si. Uma forma de passar por isso é usando o método .slice, para destacarmos uma parte do array(ou ele todo), e armazenar no novo array.

const array1 = [1, 2, 3];
const array2 = array1.slice();
array2.push(4);
console.log(array1);
console.log(array2);

//SHORTCUT para armazenar um valor de um objeto numa variável, ou em várias variáveis, assim desestruturando(destructuring) o objeto em variáveis individuais.

const [firstValue, secondValue, thirdValue] = [1, 2, 3]
console.log(firstValue)
console.log(secondValue)
console.log(thirdValue)

//Voltando a loops, menção a instrução "break;", que finaliza o loop imediatamente ao ser atingida, também funcional para o caso da estrutura de controle "switch;". Aqui também temos a instrução "continue;", que progride o loop com a exceção do valor que carrega, no caso '3', o loop segue contsagem de 0 a 10 porém com "continue === 3", sendo 'i === 3' o continue é disparado e o número 3 é pulado da contagem, chegando a 8 onde há a instrução "break;"

for (let i = 0; i <= 10; i++) {
    if(i === 3) {
        continue;
    }
    console.log(i)
    
    if (i === 8) {
        break;
    }
}

for (let i = 0; i <= 10; i++) {
    if(i%3 === 0 ) {
        continue;
    }
    console.log(i)
}

let i = 1;

while(i <= 10) {
    if(i % 3 === 0) {
        i++
        continue;
    }
    console.log(i);
    i++
}

//Um fator interessante sobre funções, é que são pedaços de código reutilizáveis, e podemos usar esses códigos diversas vezes adaptando para cada necessidade, no caso usamos a função 'doubleArray' para dobrar os valores numéricos de um array, usamos um código muito semelhante anteriormente mas com as novas mudanças, podemos utilizar qualquer array na mesma função e o resultado ainda é correto. Temos a aparição da instrução 'return', que devolve um valor para onde a função é chamada, e encerra imediatamente a função ao ser executado, no exemplo abaixo, ao encontrar um número 0 (zero), a função retorna o resultado sem chegar ao fim do array propriamente.

const nums2 = [8, 7, 6];

function doubleArray(nums) {
    const numsDoubled = [];
    for(let i = 0; i < nums.length; i++) {
        const num = nums[i];
        if (num === 0) {
            return numsDoubled ;
        }
        numsDoubled.push(num * 2);
    }
    return numsDoubled;
}
doubleArray([2, 2, 2])
doubleArray([2, 2, 5])
doubleArray([nums2])

console.log(doubleArray([2, 2, 5, 0, 5]))
*/
</script>
</body>
</html>